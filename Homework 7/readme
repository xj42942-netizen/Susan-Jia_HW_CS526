Name: Susan Jia
Course: CS 526 HW7
Assignment: Huffman Encoding Project


FILES INCLUDED
--------------
encode.py
    - Huffman encoding program
decode.py 
    - Huffman decoding program
input.txt 
    - Original input text used for testing
encoded.bin 
    - Compressed bitstring generated by encode.py
tree.pkl  
    - Serialized Huffman tree used for decoding
reconstructed.txt 
    - Final decompressed output
README.txt 
    - This document


HOW TO RUN
----------
1. Run the encoder:
       $ python3 encode.py

   This generates:
       - encoded.bin
       - tree.pkl
       - printed frequency map, Huffman tree, codes, and bitstring

2. Run the decoder:
       $ python3 decode.py

   This generates:
       - reconstructed.txt
       - printed decoded text

3. (Optional) Verify correctness:
       $ diff input.txt reconstructed.txt 


HEART OF THE ALGORITHM
----------------------

The algorithm follows the exact Huffman Coding procedure covered in class.  
Below is a breakdown of the core steps and why they work.


STEP 1: COUNT CHARACTER FREQUENCIES
-----------------------------------
Scan the input text and count how many times each character appears.

Example:
    ' ' → 28
    's' → 18
    'e' → 16

Implementation:
    freq_map = Counter(text)

This frequency distribution determines how codes will be assigned.


STEP 2: BUILD THE HUFFMAN TREE (Core Step)
------------------------------------------
This is the heart of the algorithm.

We use a min-heap to merge the two lowest-frequency nodes repeatedly:

1. Create a leaf node for every character.
2. Push nodes into a priority queue (min-heap).
3. Repeatedly:
       - Pop two nodes with the smallest frequencies.
       - Create a new parent whose frequency = the sum of the two children.
       - Attach children (left/right).
       - Push parent back into the heap.
4. Continue until only one node remains — this becomes the Huffman root.

Why this works:
    - Frequent characters end up closer to the root → shorter bitstrings.
    - Rare characters end up deeper → longer bitstrings.
    - This greedy merging process yields optimal prefix-free codes.

Implementation:
    heap = [Node(c, f) for c, f in freq_map.items()]
    heapq.heapify(heap)
    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)
        parent = Node(None, left.freq + right.freq)
        parent.left = left
        parent.right = right
        heapq.heappush(heap, parent)


STEP 3: GENERATE PREFIX-FREE CODES
-----------------------------------
Traverse the Huffman tree from the root:

    Left child  → append '0'
    Right child → append '1'

When you reach a leaf, the path is the code for that character.

Example result:
    ' ' → "101"
    's' → "001"
    'x' → "0110100"

Implementation:
    def generate_codes(node, path=""):
        if node.char is not None:
            codes[node.char] = path
        else:
            generate_codes(node.left, path + "0")
            generate_codes(node.right, path + "1")


STEP 4: ENCODE THE TEXT
------------------------
Replace each character with its Huffman code.

Example (from my input):
    Huffman → 110011000001011101110111100010

Implementation:
    encoded = "".join(codes[ch] for ch in text)

Saving:
    with open("encoded.bin", "w")...
    with open("tree.pkl", "wb")...


STEP 5: DECODE THE BITSTRING
-----------------------------
Reconstruct original text by walking the tree:

    - Start at root
    - Read bits:
          '0' → go left
          '1' → go right
    - When reaching a leaf:
          output that character
          reset to root

Implementation:
    node = root
    for bit in encoded:
        node = node.left if bit == "0" else node.right
        if node.char:
            result.append(node.char)
            node = root


End of README.
